% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sdmProfiling.R
\name{sdmProfiling}
\alias{sdmProfiling}
\title{Run SDM profiling for unsampled sites}
\usage{
sdmProfiling(
  unsampledCoords,
  sampledCoords,
  origSDM,
  envStack,
  sdmFun = "sdmModelling",
  sdmFunArgs = list(samples = NULL, envStack = NULL, modFormula = NULL, ntrees = 500),
  parallel = FALSE,
  noCores = 2
)
}
\arguments{
\item{unsampledCoords}{data frame of unsampled cells for which we wish to
run SDM profiling on, with column names "x", "y" and "ID"}

\item{sampledCoords}{data frame of sampled cells used to build original SDM,
with column names "presence" (0 = absence, 1 = presence), "x" and "y"}

\item{origSDM}{raster file of the probability of occurrences of the original
SDM built using the sampled cells (i.e. those in \code{'sampledCoords'})}

\item{envStack}{raster stack of environmental variables for building SDM}

\item{sdmFun}{name of modelling function to use. The default,
\code{'sdmModelling'}, is the built-in random forest model. The user can
use their own defined function as long as the output is a single raster
object of the predicted probability of occurrences}

\item{sdmFunArgs}{a list with the arguments for the sdmFun (which is called
through \code{do.call}). The first argument should be the coordinates with
to build the model, and will be automatically generated and replaced the
first list item. See the examples for how it works with the default random
forest SDM function.}

\item{parallel}{TRUE or FALSE to whether to run profiling on multiple cores}

\item{noCores}{if parallel = TRUE then the number of cores to share jobs to.
If noCores is larger than values retrieved through parallel::detectCores(),
then the values from parallel::detectCores() (the total number of cores on
the machine) will be used. Be wary of memory requirements when thinking
about how many cores to use/}

\item{modFormula}{model formula if using built-in random forest model}

\item{ntrees}{number of trees for generating forest if using built-in
random forest model}
}
\value{
A data frame containing results of the SDM profile where each row is
 an unsampled cell and eight columns:
 the 'x' and 'y' coordinates of the unsampled cells we profiled;
 the sum standardised channge in probability of occurrencces when the
 unsampled point was changed to an absence ('diff0') or presence ('diff1');
 the leverage values ('redundancy', 'presence_leverage', 'absence_leverage'
 and  'dual_leverage') measured as the distance to the four corners of the
 profile plot.
}
\description{
Run SDM profiling for unsampled sites
}
\examples{
set.seed(9999)
envSet <- create_env_nsets(cellDims = c(100, 100),
                           sets     = c(4, 4, 3, 1),
                           model    = "Sph",
                           psill    = 1.5,
                           dep1     = 1,
                           rangeFun = function() exp(runif(1, 1, 6)),
                           propSamp = 0.25)

### generate a virtual species from the variables
sp <- create_sp(envStack = envSet,
                spFun    = "x[1] * x[5] * x[9]",
                spModel  = "Sph",
                spPsill  = 1,
                spRange  = 500,
                propSamp = 0.5,
                prev     = 0.1)

### an initial 'sample' of the species (assuming perfect detection)
sampPts <- data.frame(sampleRandom(sp$presence, 50, na.rm = TRUE, xy = TRUE))

### a formula to fit to random forest (additive for all vars + quadratics)
form <- paste0("presence ~ ", paste(names(envSet), collapse = " + "), "+ I(",
                paste(names(envSet), collapse = " ^ 2) + I("), " ^ 2)")

### run the initial model
spMod <- sdmModelling(samples = sampPts,
                      envStack = envSet,
                      modFormula = form,
                      ntrees = 500,
                      plot = FALSE)

### a random set of 500 points to profile
unsampPts <- data.frame(x = runif(500, 1, 100), y = runif(500, 1, 100))
unsampPts <- unsampPts[!paste(unsampPts$x, unsampPts$y) \%in\%
                         paste(sampPts$x, sampPts$y), ]

profile <- sdmProfiling(unsampledCoords = unsampPts,
                        sampledCoords   = sampPts,
                        origSDM         = spMod,
                        envStack        = envSet,
                        sdmFun          = "sdmModelling",
                        sdmFunArgs      = list(samples    = NULL,
                                               envStack   = envSet,
                                               modFormula = form,
                                               ntrees     = 50),
                        parallel = FALSE)

}
\author{
Charlie Marsh (charlie.marsh@mailbox.org) & Yoni Gavish
}
